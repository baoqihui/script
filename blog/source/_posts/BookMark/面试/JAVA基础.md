---
title: JAVA基础.md
date:  2022/9/8 18:01
category_bar: true
categories: 面试
tags:
- JAVA
---
# JAVA基础

---
[toc]
---

## 一、常见异常类以及继承机制：

![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1628462559515.png)


## 二、Final关键字作用

类防止被继承

方法防止被重写

变量防止被修改

天生是线程安全的，而不需要额外的同步开销

## 三、equals和==

equals是判断两个变量或者实例指向同一个内存空间的值是不是相同，**比值**

而==是判断两个变量或者实例是不是指向同一个内存空间，**比地址**

引用类型放地址，基本数据类型放值

## Object中的equals()和hashcode()的联系

hashCode()是Object类的一个方法,返回一个哈希值.如果两个对象根据equal()方法比较相等,那么调用这两个对象中任意一个对象的hashCode()方法必须产生相同的哈希值;如果两个对象根据eqaul()方法比较不相等,那么产生的哈希值不一定相等

## 四、synchronized关键字了解吗

synchronized是一种同步锁

+ 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；
+ 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 
+ 修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；
+ 修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。

## 说说进程,线程之间的区别?

+ 进程是程序运行和资源分配的基本单位,一个程序至少有一个进程,一个进程至少有一个线程.进程在执行过程中拥有独立的内存单元

+ 线程是进程的一个实体,是cpu调度和分派的基本单位,是比程序更小的能独立运行的基本单位.同一进程中的多个线程之间可以并发执行

## 线程池初始化的时候有那些参数

 

## 线程的实现：

+ 继承Thread类：必须重写run()方法，等待CPU进行调度
+ 实现Runnable接口

## 多线程与锁的使用

```
class ThRun implements Runnable{
   private int ticket=5;
   public void run(){
      for(int i=0;i<10;i++){
         //synchronized (this){
            if(ticket>0){
            try{
                  Thread.sleep(1000);
            System.out.println("车票:"+ticket--);
            }
            catch(InterruptedException e){
               e.printStackTrace();
            }
         
         }
         //}
         
      }
   }
 }
 public class Operation {
    public static void main(String args[]){
      ThRun m=new ThRun();
      Thread t1=new Thread(m);
      Thread t2=new Thread(m);
      Thread t3=new Thread(m);
      t1.start();
      t2.start();//线程就绪状态
      t3.start();
    }
 }
```

## String,StringBuffer和StringBuilder区别?

String是字符串常量,final修饰;StringBuffer字符串变量(线程安全);StringBuilder 字符串变量(线程不安全).此外StringBuilder和StringBuffer实现原理一样,都是基于数组扩容来实现的.a=a+b与a+=b有什么区别吗?

## a=a+b与a+=b有什么区别吗?

`+=`操作符会进行隐式自动类型转换,此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型,而a=a+b则不会自动

## 了解泛型么?简述泛型的上界和下界?

有时候希望传入的类型有一个指定的范围，从而可以进行一些特定的操作,这时候就需要通配符了?在Java中常见的通配符主要有以下几种:

    <?>: 无限制通配符
    <? extends E>: extends 关键字声明了类型的上界,表示参数化的类型可能是所指定的类型,或者是此类型的子类
    <? super E>: super关键字声明了类型的下界,表示参数化的类型可能是指定的类型,或者是此类型的父类
## 简单的解释一下垃圾回收?

JVM中垃圾回收机制最基本的做法是分代回收.内存中的区域被划分成不同的世代,对象根据其存活的时间被保存在对应世代的区域中.一般的实现是划分成3个世代:年轻,年老和永久代.所有新生成的对象优先放在年轻代的(大对象可能被直接分配在老年代,作为一种分配担保机制),年轻代按照统计规律被分为三个区:一个Eden区，两个 Survivor区.在年轻代中经历了N次垃圾回收后仍然存活的对象,就会被放到年老代中.因此可以认为年老代中存放的都是一些生命周期较长的对象.

方法区也被称为永久代,用于存储每一个java类的结构信息:比如运行时常量池,字段和方法数据,构造函数和普通方法的字节码内容以及类,实例,接口初始化时需要使用到的特殊方法等数据,根据虚拟机实现不同,GC可以选择对方法区进行回收也可以不回收.

## 常见的垃圾回收算法有哪些

标记-清除

标记-复制

标记-整理

分代回收

## 如何判断一个对象是否应该被回收?

这就是所谓的对象存活性判断,常用的方法有两种:

- 引用计数法：可能存在互相引用导致无法
- 对象可达性分析

## 产生死锁的条件

1.互斥条件：一个资源每次只能被一个进程使用。
 2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
 3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
 4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

## wait()与sleep()的区别

+ sleep()来自Thread类，和wait()来自Object类.调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁
+ sleep()睡眠后不出让系统资源，wait让其他线程可以占用CPU
+ sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒.而wait()需要配合notify()或者notifyAll()使用

## 怎么唤醒一个阻塞的线程
如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。

## 什么是线程局部变量ThreadLocal

线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。

## ThreadLoal的作用是什么?

简单说ThreadLocal就是一种以空间换时间的做法在每个Thread里面维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了.

## 集合

## 网络

## io













