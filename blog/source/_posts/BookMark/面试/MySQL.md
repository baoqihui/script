---
title: MySQL.md
date:  2022/9/8 18:01
category_bar: true
categories: 面试
tags:
- mysql
---
# mysql

[toc]

---

![image-20220721150215750](https://img-1256282866.cos.ap-beijing.myqcloud.com/image-20220721150215750.png)

## 一、 数据库的三范式是什么

+ 第⼀范式：强调的是列的原⼦性，
+ 第⼆范式：第一范式基础上，确保每列都与主键相关
+ 第三范式：第二范式的基础上,目标是确保每列都和主键列直接相关,而不是间接相关

## 二、ACID

+ Atomicity（原⼦性）：⼀个事务（transaction）中的所有操作，或者全部完成，或者全部不完成.
+ Consistency（⼀致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。 
+ Isolation（隔离性）：数据库允许多个并发事务同时对其数据进⾏读写和修改的能⼒，隔离性可以 防⽌多个事务并发执⾏时由于交叉执⾏⽽导致数据的不⼀致。事务隔离分为不同级别，包括读未提交 （Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串⾏化 （Serializable）。 
+ Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

## 三、 mysql 索引是怎么实现的

+ 索引是满⾜某种特定查找算法的数据结构，⽽这些数据结构会以某种⽅式指向数据，从⽽实现⾼效查找数据。
+ 常见的MySQL主要有两种结构：Hash索引和B+ Tree索引，我们使用的是InnoDB引擎，默认的是B+树

## 四、索引优缺点

+ 优点：
  + 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
  + 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
+ 缺点：
  + 时间方面:创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率;
  + 空间方面:索引需要占物理空间。

## 五、常用索引类型

主键索引，唯一索引，普通索引，全文索引

## 六、 什么是聚簇索引﹖何时使用聚簇索引与非聚簇索引

+ 聚簇索引:将数据存储与索引放到了一块，找到索引也就找到了数据
+ 非聚簇索引:将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应。查询慢

## 七、 联合索引是什么？为什么要注意顺序？

同一个字段建立多个索引，但必须按照顺序，从频繁到不频繁使用

## 八、什么是事务？

事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。

## 九、脏读，幻读，不可重复读

+ 脏读：⼀个线程中的事务读到了另外⼀个线程中未提交的数据。
+ 不可重复读：⼀个线程中的事务读到了另外⼀个线程中已经提交的update的数据（前后内容不⼀样）
+ 虚读（幻读）：⼀个线程中的事务读到了另外⼀个线程中已经提交的insert或者delete的数据（前后条数不⼀样）

## 十、mysql锁

+ 当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。
+ 共享锁:又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。
+ 排他锁:又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。

## 十一、 MysQL中InnoDB引擎的行锁是怎么实现的?

InnoDB是基于索引来完成行锁例: select * from tab_with_index where id= 1 for update;

## 十二、 什么是死锁?怎么解决?

+ 死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。
+ 常见的解决死锁的方法
  1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
  2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率;
  3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率;
  如果业务处理不好可以用分布式事务锁或者使用乐观锁

## 十三、数据库的乐观锁和悲观锁是什么?怎么实现的?

并发控制主要采用的技术手段

+ 悲观锁:假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式:使用数据库中的锁机制
+ 乐观锁:假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式:一般会使用版本号机制。

## 十四、关联查询

交叉查询，内连接（inner join），外连接(left join,right join)，联合查询(union,union all)

## 十五、sql优化

+ 先找慢的原因，通过explain命令查询执行计划；看看是因为什么，加载无用数据太多？还是查询数据多？
+ 查看索引，如果没有则建立索引。如果有看是否命中。（例：确保GROUP BY和ORDER BY只有一个表中的列，这样MysQL才有可能使用索引。）
+ 开启慢查询日志：用于记录执行时间超过某个临界值的SQL日志,用于快速定位慢查询，为我们的优化做参考。
+ 还有一些细节的问题：比如字段是不是允许为空了；身份证号，手机号这种固定长度的字段选char固定长度。多用limit，少用select *，!=，in,not in；limit大分页时可以记录上次最大id，下次后延。
+ 拆分为小查询。子查询替换为关联查询。

## 十六、大表数据查询，怎么优化

1.优化shema、sql语句+索引;
2.第二加缓存，memcached, redis ;
3.主从复制，读写分离;
4．垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统;
5．水平切分，针对数据量大的表，要选择一个合理的关联字段，产生冗余，避免多次联合查询

## 十七、分库分表，主从复制

+ sql优化或者水平切分后还无法优化，就要考虑分库分表或者物理机性能因素。
+ 因为我们的数据量还没有到达这个级别，所以并没有使用。只是了解过。但分库分表后会产生一些问题，比如事务的支持，跨节点调取数据，求count，甚至id问题。
+ 主从复制:将主数据库中的DDL和 DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做)﹔从而使得从数据库的数据与主数据库保持一致。

## 十八、union unionall区别

+ union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；
+ union All：对两个结果集进行并集操作，包括重复行，不进行排序；

## 十九、b+树的优点

+ 由于叶节点之间有指针相连，B+ 树更适合范围检索；

+ 由于非页节点只保存关键字和指针，同样大小非叶节点，B+ 树可以容纳更多的关键字，可以降低树高，查询时磁盘读写代价更低；

+ B+ 树的查询效率比较稳定。任何关键字的查找必须走一条从根结点到叶子结点的路，所有关键字查询的路径长度相同，效率相当。

## 二十、什么情况导致索引不生效

like 左%索引；索引字段上函数；group/order by两个表

## 四种隔离级别

1.读未提交（Read uncommitted）：这种事务隔离级别下，select语句不加锁。此时，可能读取到不一致的数据，即“读脏 ”。这是并发最高，一致性最差的隔离级别。

2.读已提交（Read committed）：可避免 脏读 的发生。

在互联网大数据量，高并发量的场景下，几乎 不会使用 上述两种隔离级别。

3.可重复读（Repeatable read）：MySql默认隔离级别。可避免 脏读 、不可重复读 的发生。

4.串行化（Serializable ）：可避免 脏读、不可重复读、幻读 的发生。

![image-20220721150228883](https://img-1256282866.cos.ap-beijing.myqcloud.com/image-20220721150228883.png)

