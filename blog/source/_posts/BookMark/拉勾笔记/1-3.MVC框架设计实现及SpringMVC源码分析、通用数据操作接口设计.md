---
title: 1-3.MVC框架设计实现及SpringMVC源码分析、通用数据操作接口设计.md
date:  2022/9/7 10:46
category_bar: true
categories: 拉勾笔记
tags:
- Spring mvc
---
# 阶段一模块三学习笔记
## 一、Spring概念相关
基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级Web 框架，是spring的后续产品，本质是对serlvet的封装。作⽤：1）接收请求 2）返回响应，跳转⻚⾯

## 二、开发过程
1）配置DispatcherServlet前端控制器
2）开发处理具体业务逻辑的Handler（@Controller、@RequestMapping）
3）xml配置⽂件配置controller扫描，配置springmvc三⼤件
4）将xml⽂件路径告诉springmvc（DispatcherServlet）

## 三、Spring mvc请求处理流程
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1628385306565.png)
## 四、自定义类型转换器
+ 新建一个类型转换器实现Convert接口
```
public class DateConverter implements Converter<String, Date> {
    @Override
    public Date convert(String source) {
        // 完成字符串向日期的转换
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");

        try {
            Date parse = simpleDateFormat.parse(source);
            return parse;
        } catch (ParseException e) {
            e.printStackTrace();
        }

        return null;
    }
}
```
+ springmvc.xml中注册
```
<!--
	自动注册最合适的处理器映射器，处理器适配器(调用handler方法)
-->
<mvc:annotation-driven conversion-service="conversionServiceBean"/>

<!--注册自定义类型转换器-->
<bean id="conversionServiceBean" class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
	<property name="converters">
		<set>
			<bean class="com.lagou.edu.converter.DateConverter"></bean>
		</set>
	</property>
</bean>
```
## 五、restful风格
### 1.概念：
Restful 是⼀种 web 软件架构⻛格，它不是标准也不是协议，它倡导的是⼀个资源定位及资源操作的⻛格；将原本的参数放到uri本身。通过请求类型获取资源。
### 2.Restful 的优点
它结构清晰、符合标准、易于理解、扩展⽅便，所以正得到越来越多⽹站的采⽤。
### 3.与原有接口请求的区别
+ http://localhost:8080/user/queryUserById.action?id=30（原）
+ http://localhost:8080/user/3 （resuful风格）
### 4. 接口请求类型区分增删改查
POST:增；DELETE：删； PUT：改；GET ：查
### 5.spring mvc中的restful风格使用
+ @PathVariable取出uri中的参数
 ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1628394137560.png)
 + @RequestBody取出json类型参数
 + @ResponseBody返回json类型结果
## 六、spring mvc拦截器
1. 区分拦截器、监听器、过滤器
Servlet：处理Request请求和Response响应
+ 过滤器（Filter）：对Request请求起到过滤的作⽤，作⽤在Servlet之前，如果配置为可以对所有的资源访问（servlet、js/css静态资源等）进⾏过滤处理
+ 监听器（Listener）：实现了javax.servlet.ServletContextListener 接⼝的服务器端组件，它随Web应⽤的启动⽽启动，只初始化⼀次，然后会⼀直运⾏监视，随Web应⽤的停⽌⽽销毁
	+ 作⽤⼀：做⼀些初始化⼯作，web应⽤中spring容器启动ContextLoaderListener
	+ 作⽤⼆：监听web中的特定事件，⽐如HttpSession,ServletRequest的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控，⽐如统计在线⼈数，利⽤HttpSessionLisener等。
+ 拦截器（Interceptor）：是SpringMVC、Struts等表现层框架⾃⼰的，不会拦截jsp/html/css/image的访问等，只会拦截访问的控制器⽅法（Handler）。
	+ 在Handler业务逻辑执⾏之前拦截⼀次
	+ 在Handler逻辑执⾏完毕但未跳转⻚⾯之前拦截⼀次
	+ 在跳转⻚⾯之后拦截⼀次
+ 从配置的⻆度也能够总结发现：serlvet、filter、listener是配置在web.xml中的，⽽interceptor是配置在表现层框架⾃⼰的配置⽂件中的
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1628403797565.png)
2. 配置spring mvc拦截器
+ 实现HandlerInterceptor接口
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1628404625289.png)
+ 在springmvc.xml中配置拦截路径
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1628404603483.png)
## 七、上传文件
+ spring mvc中配置多元素解析器
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1628405767931.png)
+ controller
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1628405749347.png)
## 八、异常处理
全局异常捕捉使用@ControllerAdvice，方法上使用@ExceptionHandler
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1628406265119.png)

## 九、转发和重定向
+ 转发：A 找 B 借钱400，B没有钱但是悄悄的找到C借了400块钱给A；url不会变,参数也不会丢失,⼀个请求
+ 重定向：A 找 B 借钱400，B 说我没有钱，你找别⼈借去，那么A ⼜带着400块的借钱需求找到C url会变,参数会丢失需要重新携带参数,两个请求
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1628406931978.png)

+  源码：`git clone -b master1 https://gitee.com/idse666666/my_spring-mvc.git`
---
## 十、手写mvc框架
### 1. spring mvc执行的大致流程
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1628422781354.png)
### 2. 相关解析过程的Java方法记录
#### 2.1 Java中的Properties类
+ 主要用于读取Java的配置文件
+ load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。
+ getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。
#### 2.2 获取配置传入路径，返回流。
+ `InputStream resourceAsStream = this.getClass().getClassLoader().getResourceAsStream(contextConfigLocation);`
*  this.getClass()调用对象的getClass()方法是获得对象当前的类类型
* 在类类型上调用getClassLoader()方法是得到当前类型的类加载器
* 类加载器的getResourceAsStream()方法来加载资源

#### 2.3 获取当前线程项目所在的绝对路径
+ `Thread.currentThread().getContextClassLoader().getResource("").getPath();`
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1628426058897.png)

#### 2.4 反射方式注入某个字段的值
```
declaredField.setAccessible(true);
declaredField.set(注入字段,“要注入的值”);
```
### 3. 手写mvc初始化过程
#### 3.1 加载配置文件 springmvc.properties
#### 3.2 扫描相关的类，扫描注解
#### 3.3 初始化bean对象（实现ioc容器，基于注解）
#### 3.4 实现依赖注入
#### 3.5 构造一个HandlerMapping处理器映射器，将配置好的url和Method建立映射关系
+  源码：`git clone -b master2 https://gitee.com/idse666666/my_spring-mvc.git`

## 十一、SSM整合

### 1. spring 整合 mybatis

#### 1.1整合⽬标

+ 数据库连接池以及事务管理都交给Spring容器来完成

+ SqlSessionFactory对象应该放到Spring容器中作为单例对象管理

+ Mapper动态代理对象交给Spring管理，我们从Spring容器中直接获得Mapper的代理对象

#### 1.2在测试类中进行service层测试

```
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {"classpath*:application*.xml"})
public class MybatisSpringTest {
    @Autowired
    private IAccountService accountService;
    @Test
    public void testMybatisSpring(){
        List<Account> accounts = accountService.queryAccounts();
        for (Account account : accounts) {
            System.out.println(account);
        }
    }
}
```

#### 1.3 applicatisonContext.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd
">

    <!--包扫描-->
    <context:component-scan base-package="com.lagou.edu"/>


    <!--数据库连接池以及事务管理都交给Spring容器来完成-->

    <!--引入外部资源文件-->
    <context:property-placeholder location="classpath:jdbc.properties"/>

    <!--第三方jar中的bean定义在xml中-->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${jdbc.driver}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>



    <!--SqlSessionFactory对象应该放到Spring容器中作为单例对象管理

        原来mybaits中sqlSessionFactory的构建是需要素材的：SqlMapConfig.xml中的内容
    -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <!--别名映射扫描-->
        <property name="typeAliasesPackage" value="com.lagou.edu.pojo"/>
        <!--数据源dataSource-->
        <property name="dataSource" ref="dataSource"/>
    </bean>



    <!--Mapper动态代理对象交给Spring管理，我们从Spring容器中直接获得Mapper的代理对象-->
    <!--扫描mapper接口，生成代理对象，生成的代理对象会存储在ioc容器中-->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <!--mapper接口包路径配置-->
        <property name="basePackage" value="com.lagou.edu.mapper"/>
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>
    </bean>
    
    <!--事务管理-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!--事务管理注解驱动-->
    <tx:annotation-driven transaction-manager="transactionManager"/>
</beans>
```

+ 源码：`git clone -b master3 https://gitee.com/idse666666/my_spring-mvc.git`

### 2. spring 整合 mybatis后整合mvc

#### 2.1 springmvc.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       http://www.springframework.org/schema/mvc/spring-mvc.xsd
">
    <!--扫描controller-->
    <context:component-scan base-package="com.lagou.edu.controller"/>

    <!--配置springmvc注解驱动，自动注册合适的组件handlerMapping和handlerAdapter-->
    <mvc:annotation-driven/>
</beans>
```

#### 2.2 web.xml

```
<!DOCTYPE web-app PUBLIC
 "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
 "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
  <display-name>Archetype Created Web Application</display-name>
  <!--加载spring配置文件（含mybatis）-->
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath*:applicationContext*.xml</param-value>
  </context-param>
  <!--spring框架启动-->
  <listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>


  <!--springmvc启动-->
  <servlet>
    <servlet-name>springmvc</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath*:springmvc.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>


  <servlet-mapping>
    <servlet-name>springmvc</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>
</web-app>

```

+ 源码：`git clone -b master4 https://gitee.com/idse666666/my_spring-mvc.git`
