---
title: 1-1.持久层框架设计实现及MyBatis源码分析.md
date:  2022/9/7 10:45
category_bar: true
categories: 拉勾笔记
tags:
- MyBatis
---
# 阶段一模块一学习笔记-持久层框架设计实现及MyBatis源码分析
[toc]
## 一、自定义持久层框架
### 1. JDBC问题总结：
原始jdbc开发存在的问题如下：
1. 数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。
2. Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变
java代码。
3. 使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能
多也可能少，修改sql还要修改代码，系统不易维护。
4. 对结果集解析存在硬编码(查询列名)，sql变化导致解析代码变化，系统不易维护，如果能将数据 库
记录封装成pojo对象解析比较方便
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627220659738.png)
### 2. 问题解决思路
1. 使用数据库连接池初始化连接资源
2. 将sql语句抽取到xml配置文件中
3. 使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射

### 3. 自定义框架设计
使用端：
提供核心配置文件：

+ sqlMapConfig.xml : 存放数据源信息，引入mapper.xml
+ Mapper.xml : sql语句的配置文件信息
框架端：
1. 读取配置文件
读取完成以后以流的形式存在，我们不能将读取到的配置信息以流的形式存放在内存中，不好操作，可
以创建javaBean来存储
（1）Configuration : 存放数据库基本信息、Map<唯一标识，Mapper> 唯一标识：namespace + "." +
id
（2）MappedStatement：sql语句、statement类型、输入参数java类型、输出参数java类型
2. 解析配置文件
创建sqlSessionFactoryBuilder类：
if (connection != null) { try {connection.close(); } catch (SQLException e) { e.printStackTrace(); }} }
方法：sqlSessionFactory build()：
第一：使用dom4j解析配置文件，将解析出来的内容封装到Configuration和MappedStatement中
第二：创建SqlSessionFactory的实现类DefaultSqlSession
3. 创建SqlSessionFactory：
方法：openSession() : 获取sqlSession接口的实现类实例对象
4. 创建sqlSession接口及实现类：主要封装crud方法
方法：selectList(String statementId,Object param)：查询所有
selectOne(String statementId,Object param)：查询单个
具体实现：封装JDBC完成对数据库表的查询操作
涉及到的设计模式：
Builder构建者设计模式、工厂模式、代理模式

### 4. 实际项目目录分析
+ 使用端：![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627208458929.png)
+ 框架端：![22222222 ](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627210514597.png)
+ 源码：`git clone -b master1 https://gitee.com/idse666666/lagou.git`

### 5. 优化
#### 5-1： 将测试类方法
 ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627220851997.png)
 封装为分别的dao方法
 ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627220727857.png)

#### 5-2： 仍存在问题：
+ dao的实现类中存在重复的代码，整个操作的过程模板重复(加载配置文件、创建sqlsessionFactory,调用sqlsession方法)
+ dao的实现类中存在硬编码，调用sqlsession的方法时，参数statement的id硬编码
#### 5-3: 解决方式
+ 使用代理模式生成dao层接口的代理实现类
+ SqlSessionImpl中添加如下方法
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627222822750.png)
+ 使xml中的路径对应上到层路径，xml方法名对应dao层方法名，此时就可以删除UserDao的接口实现类了
 ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627222658101.png)
  ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627222698830.png)
 + 源码：`git clone -b master2 https://gitee.com/idse666666/lagou.git`
### 6.课后小结以及个人思考
+ 课后练习：![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627223280077.png)
+ 个人思考：mybatis的自定义实现是：xml配置方式记录数据库连接信息以及想要执行的sql->以文件流形式传入到框架端->框架端解析后利用其构建sqlsessionFactory工厂->使用工厂生产sqlsession->sqlsession实现具体的sql方法->有参数的sql需要使用对应工具类->优化过程使用代理模式，用dao层的包名.方法名巧妙映射xml中的namespace.id 从而解决了硬编码，代码重复问题


## 二、mybatis
### 1.相关概念
1. ORM:ORM完成面向对象的编程语言到关系数据库的映射;ORM框架实现的效果：把对持久化对象的保存、修改、删除 等操作，转换为对数据库的操作
2. 简介：MyBatis是一款优秀的基于ORM的半自动轻量级持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java对象为数据库中的记录。
3. Mybatis的优势：Mybatis是一个半自动化的持久层框架，对开发人员开说，核心sql还是需要自己进行优化，sql和java编码进行分离，功能边界清晰，一个专注业务，一个专注数据。

### 2.具体实现
1. 编写SqlMapperConfig.xml，其中配置mapper.xml信息
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627309657721.png)
2. UserMapper.xml信息
 ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627309622171.png)
3. 生产出sqlsession后调用其selectList接口即可，添加insert，修改update，删除delete。除了查询都需要提交事务。传递参数信息。
 ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627309710914.png)

### 3、优化：
1. 优化一：使用dao层实现，实则仍需要加载配置文件创建工厂以及生产sqlsession：
 ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627309868032.png)
 + 源码：`git clone -b master3 https://gitee.com/idse666666/lagou.git`
+ 省略掉dao层实现，直接将mapper.xml的namespace对应到dao的资源包
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627349047511.png)
+ 使用配置文件
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627349958103.png)
### 2. mybatis常用标签：
+ 一对一映射：association
+ 一对多映射：collection
+ 判断：if
+ 循环：foreach
 ```
 //例：
<if test="p.depaCode != null and p.depaCode != ''">
	and u.depa_code in
	<foreach collection="p.umsDepas" separator="," close=")" open="(" item="item" index="index">
		#{item}
	</foreach>
</if>
 ```
+ 源码 `git clone -b master4 https://gitee.com/idse666666/lagou.git`
### 3.mybatis缓存
#### 3-1. 缓存概念:
+ 缓存就是内存中的数据，常常来自对数据库查询结果的保存，使用缓存，我们可以避免频繁的与数据库进行交互，进而提高响应速度
+ 一级缓存是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的
+ 二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的
+ ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627351056167.png)

#### 3-2. 验证一级缓存：
+ 一级缓存验证
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627352164726.png)
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627352750919.png)
+ 总结：
2-1. 第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从 数据
库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。
2-2. 如果中间sqlSession去执行commit操作（执行插入、更新、删除），则会清空SqlSession中的 一级
缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。
2-3. 第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直 接从
缓存中获取用户信息
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627352847320.png)
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627352927837.png)

#### 3-3. 一级缓存源码分析
 + 找到源码的存储结构为HashMap
 ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627353646287.png)
 + 在执行query方法时，判断缓存的存在状态，存在直接取出，不存在查询数据库
 ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627354352297.png)
    查询数据库得到结果后放入一级缓存中
    ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627354509667.png)

#### 3-4. 二级缓存
+  二级缓存的原理和一级缓存原理一样，第一次查询，会将数据放入缓存中，然后第二次查询则会直接去缓存中取。但是一级缓存是基于sqlSession的，而二级缓存是基于mapper文件的namespace的，也就是说多个sqlSession可以共享一个mapper中的二级缓存区域，并且如果两个mapper的namespace 相同，即使是两个mapper,那么这两个mapper中执行sql查询到的数据也将存在相同的二级缓存区域 中
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627355579497.png)

+ 二级缓存需要手动开启
 ```
 //sqlMapConfig.xml中
<!--开启二级缓存  -->
<settings>
	<setting name="cacheEnabled" value="true"/>
</settings>
//mapper.xml中
<!--开启二级缓存--> 
<cache>
</cache>
//或者注解方式在mapper接口上方
@CacheNamespace
//同时要注意实体类需要序列化
User implements Serializable
 ```
验证
 + 多个session在同一个mapper的namespace中，不同session会缓存数据
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627355543573.png)
+ 同一个mapper的namespace中有一个提交了增删改事务，二级缓存清空
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627357580239.png)

 二级缓存附加配置：mybatis中还可以配置userCache和flushCache等配置项
+ useCache=true（默认）改为false时禁用该statement二级缓存
+ flushCache=true（默认）改为false时禁用该statement提交事务后时刷新二级缓存（可能出现脏读）

### 4. 二级缓存自定义
+ 因为mybatis自带的二级缓存无法在分布式环境下正常使用，选用redis作为分布式缓存
+ 使用`@CacheNamespace(implementation = RedisCache.class)`注解，使用redis缓存
+ 查阅源码可知 redis配置文件名称固定：redis.properties；redisCache为HashMap
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627365518042.png)
+ 验证结果
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627364989714.png)

### 5. mybatis插件
+ mybatis在四大组件(Executor、StatementHandler、ParameterHandler、ResultSetHandler)处提供了简单易用的插 件扩展机制
+ 实际上就是一个拦截器，可以自定义
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627442491687.png)

+ 源码 `git clone -b master5 https://gitee.com/idse666666/lagou.git`

## 三、Mybatis架构原理
### 1. 架构设计
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627443325446.png)
### 2. 主要构件及其相互关系
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627449280498.png)
![3.](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627450064081.png)

### 3. 二级缓存源码优先级别
二级缓存>一级缓存>数据库
### 4. 二级缓存的存取机制
 + 只有提交了SqlSession.commit()，后二级缓存才被真正写入
 + 存储二级缓存对象的时候是放到了TransactionalCache.entriesToAddOnCommit这个map中，但是每次查询的时候是直接从TransactionalCache.delegate中去查询的，所以这个二级缓存查询数据库后，设置缓存值是没有立刻生效的，主要是因为直接存到 delegate 会导致脏数据问题
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627525322283.png)

+ MyBatis二级缓存只适用于不常进行增、删、改的数据，比如国家行政区省市区街道数据。一但数据变更，MyBatis会清空缓存。因此二级缓存不适用于经常进行更新的数据。
+ 源码 `git clone -b master6 https://gitee.com/idse666666/lagou.git`
### 5. 延迟加载
#### 5-1 延迟加载概念：
+ 就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载。
+ 优点：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表 速度要快。
+ 缺点：因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时 间，所以可能造成用户等待时间变长，造成用户体验下降
#### 5-2 实现
```
//1.返回resultMap
<select id="findById" resultMap="userMap"  >
	select * from user where id = #{id}
</select>
//2.设置fetchType="lazy，并指定子查询的全路径和参数值
<resultMap id="userMap" type="com.lagou.pojo.User">
<id property="id" column="id"></id>
<result property="username" column="username"></result>
<collection property="orderList" ofType="com.lagou.pojo.Order"
			select="com.lagou.mapper.IOrderMapper.findOrderByUid" column="id" fetchType="lazy">
	<id property="id" column="oid"/>
	<result property="orderTime" column="ordertime"/>
	<result property="total" column="total"/>
</collection>
</resultMap>
//3.子查询，需要id作为参数值
<select id="findOrderByUid" resultType="com.lagou.pojo.Order">
select * from orders where uid = #{uid}
```
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627542903512.png)
#### 5-3 通过以上配置延迟加载，实现如果只查询一级用户信息，二级查询则不会执行
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627543041878.png)
#### 5-4 全局延迟加载
```
<settings>
	<!--开启全局延迟加载功能-->
	<setting name="lazyLoadingEnabled" value="true"/> 
</settings>
```
+ 源码 `git clone -b master7 https://gitee.com/idse666666/lagou.git`

## 四、设计模式：
### 1. mybatis中用到的设计模式
![enter description here](http://img.huijia21.com/blog/1627556747649.png)
### 2. 构建者模式
#### 2-1.构建者模式概念
Builder模式的定义是"将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。”，它属于创建类模式，一般来说，如果一个对象的构建比较复杂，超出了构造函数所能包含的范围，就可以使用工厂模式和Builder模式，相对于工厂模式会产出一个完整的产品，Builder应用于更加复杂的对象的构建，甚至只会构建产品的一个部分，直白来说，就是使用多个简单的对象一步一步构建成一个复杂的对象
#### 2-2. 例：分别构建出电脑的各个组件
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627606380241.png)
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627606468588.png)

#### 2-3. mybatis中体现
SqlSessionFactoryBuilder会调用XMLConfigBuilder读取所有的
MybatisMapConfig.xml 和所有的 Mapper.xml 文件，构建 Mybatis 运行的核心对象 Configuration
对象，然后将该Configuration对象作为参数构建一个SqlSessionFactory对象。
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627608755711.png)

### 3.工厂模式
#### 3-1.简单工厂模式概念
在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类
#### 3-2.例子
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627611420381.png)
#### 3-3.mybatis中体现
SqlSessionFactory，该Factory的openSession ()方法重载了很多个，分别支持autoCommit、Executor、Transaction等参数的输入，来构建核心的SqlSession对象。该方法先从configuration读取对应的环境配置，然后初始化TransactionFactory 获得一个 Transaction 对象，然后通过 Transaction 获取一个 Executor 对象，最后通过configuration、Executor、是否autoCommit三个参数构建了 SqlSession

### 4.代理模式
#### 4-1.代理模式概念
代理模式(Proxy Pattern):给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式 的英文叫做Proxy，它是一种对象结构型模式，代理模式分为静态代理和动态代理，
#### 4-2.例子
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627613313888.png)
#### 4-3.mybatis中体现
代理模式可以认为是Mybatis的核心使用的模式，正是由于这个模式，我们只需要编写Mapper.java接口，不需要实现，由Mybatis后台帮我们完成具体SQL的执行。当我们使用Configuration的getMapper方法时，会调用mapperRegistry.getMapper方法，而该方法又会调用mapperProxyFactory.newInstance(sqlSession)来生成一个具体的代理
+ 源码 `git clone -b master8 https://gitee.com/idse666666/lagou.git`
---

阶段一模块一源码（总）：`git clone -b master https://gitee.com/idse666666/lagou.git`

















