---
title: 通过房屋租赁流程理解设计模式（单例模式，代理模式，工厂模式）.md
date:  2022/9/7 10:48
category_bar: true
categories: 拉勾笔记
tags:
- 设计模式
---
# 通过房屋租赁流程理解设计模式（单例模式，代理模式，工厂模式）
---
[toc]

---
源码:[design-pattern ](https://gitee.com/idse666666/design-pattern.git)

---
## 一、单例模式
### 1. 相关概念
 * 单例模式：应用在全局只有一个实例对象时，将自身实例化并赋值给一个属性，加载到此类时直接调用其静态实例。分为懒汉和饿汉式，此处展示饿汉式
 * 实现思路：此类为静态，只暴露getInstance方法，jvm启动过程只加载一次
 * 主要用途：整个项目只要一种配置，基本固定的值，仅实例化一次；如数据库的连接信息
### 2. 演示思路
+ 假设某地区房产中介只有一个Tom，完全垄断租房中介产业。张三Z和李四L都想在北京租房，只能找Tom。Tom不需要打太多广告，只需要把自己的名字和代理费用打印成一张名片。
### 3. 代码实现
+ 中介Tom（忽略get，set，toString）
```
public class Agent {
    //无参构造
    private Agent(){};
    //实例化
    private static Agent agent=new Agent();
    //提供实例化后的对象以便使用（Tom印制自己的名片，准备发放）
    public static Agent getInstance(){
        System.out.println("单例模式，只有我一个代理！代理权被我Tom垄断了....");
        return agent;
    }
	
    private String name;
    private Integer fee;
	
    static {
        agent.setName("tom");
        agent.setFee(500);
    }
}
```
+ 租户张三：
```
public class Tenant_Z {
    public static void main(String[] args) {
        System.out.println("张三想要租房....");
        //（找到中介公司，只有一个中介）
        Agent agent=Agent.getInstance();
        System.out.println(agent);
    }
}

```
+ 租户李四：
```
public class Tenant_L {
    public static void main(String[] args) {
        System.out.println("李四想要租房....");
		//（找到中介公司，只有一个中介）
        Agent agent=Agent.getInstance();
        System.out.println(agent);
    }
}
```
### 4. 结果演示
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627825408671.png)
![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627825434528.png)

## 二、代理模式
### 1. 相关概念
* 给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式 的英文叫做Proxy，它是一种对象结构型模式，代理模式分为静态代理和动态代理，此处演示JDK动态代理
* 实现思路：使用JDK自带的动态代理
* 主要用途：在多个业务逻辑的前后有固定的非业务方法，做出提取，代理该方法并实现加强。比如JDBC操作中，每次连接数据库进行操作都需要创建连接，最后释放连接，与实际的业务掺杂在一起。
### 2. 演示思路
仍然是租赁房屋，但风水轮流转，这次张三Z和李四L是代理，租房给Tom，不但是租赁前收取你的代理费用，还在你租赁完成后售出你的个人信息。赚两份钱，并且他还不想让你知道。只要你找他租赁，就默默的在成功给你租到房后售出信息。
### 3. 代码实现
 + 租赁行为（也就是待加强的方法，JDK动态代理代理对象必须是接口实现类）
```
// 租赁接口
public interface IRenting {
    void rent(String name);
}
//接口实现
public class RentingImpl implements IRenting {
    public void rent(String name) {
        System.out.println(name+"作为代理租赁了出一套房子");
    }
}
```
+ JDK动态代理加强方法
```
public class JDKProxy {
    public static Object getJDKProxy(Object o){
        return Proxy.newProxyInstance(o.getClass().getClassLoader(), o.getClass().getInterfaces(), new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                Object result;
                System.out.println("先收取代理费用500元");
                result = method.invoke(o, args);
                System.out.println("最后卖出客户信息5元");
                return result;
            }
        });
    }
}
```
+ Tom找张三租赁
```
public class Agent_Z {
    public static void main(String[] args) {
        System.out.println("Tom想要租房....再找张三代理...");
        IRenting renting=(IRenting)JDKProxy.getJDKProxy(new RentingImpl());
        renting.rent("张三");
    }
}
```
+ Tom找李四租赁
```
public class Agent_L {
    public static void main(String[] args) {
        System.out.println("Tom想要租房....先找李四代理...");
        IRenting renting=(IRenting)JDKProxy.getJDKProxy(new RentingImpl());
        renting.rent("李四");
    }
}
```
### 4. 结果演示
+ ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627830083514.png)
+ ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627830102262.png)

## 三、工厂模式
### 1. 相关概念
在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类
### 2. 演示思路
张三Z和李四L通过双份收入获得了第一桶金，也开启了各自的代理分公司。他们业务还是按照原来的总公司的租赁业务，但各自在租赁时开始打上自己的服务口号....
### 3. 代码实现
+ 租赁行为的总工厂以及具体实现的分工厂
```
//总工厂
public interface IRentingFactory {
    void rent();
}
//张三实现工厂
public class RentingFactory_Z implements IRentingFactory {
    public void rent() {
        System.out.println("张三租赁公司分公司为您服务...");
    }
}
//李四实现工厂
public class RentingFactory_L implements IRentingFactory {
    @Override
    public void rent() {
        System.out.println("李四租赁公司分公司为您服务...");
    }
}
```
+ Tom找张三分公司代理
```
public class Tenant_Tom_To_Z {
    public static void main(String[] args) {
        System.out.println("Tom想要租房....找张三分公司代理...");
        IRentingFactory renting=new RentingFactory_Z();
        renting.rent();
    }
}
```
+ Tom找李四分公司代理
```
public class Tenant_Tom_To_L {
    public static void main(String[] args) {
        System.out.println("Tom想要租房....找李四分公司代理...");
        IRentingFactory renting=new RentingFactory_L();
        renting.rent();
    }
}
```
### 4. 结果演示
+ ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627865477291.png)
+ ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627865453058.png)

## 四、融合三种设计模式（选读）
### 1. 演示思路
张三Z和李四L两人的公司越开越大，分别占领了该地区的南北两大地区。从此单人垄断变成双人联合垄断，各自打印各自名片，只对自己所属地区进行发放。与此同时，上级公司任然挂名，他们也仍像以前一样收取代理费后，售卖个人信息。
### 2. 代码实现
+ 租赁行为的总工厂以及具体实现的分工厂
```
//总工厂
public interface IRentingFactory {
    void rent();
}
//张三实现工厂
public class RentingFactory_Z implements IRentingFactory {
    public void rent() {
        System.out.println("张三租赁公司分公司为您服务...");
    }
}
//李四实现工厂
public class RentingFactory_L implements IRentingFactory {
    @Override
    public void rent() {
        System.out.println("李四租赁公司分公司为您服务...");
    }
}
```
+ 张三的名片
```
public class Agent_Z {
    //无参构造
    private Agent_Z(){};
    //实例化
    private static Agent_Z agent=new Agent_Z();
    //提供已经实例化的对象方便调用（张三印制自己的名片，准备发放）
    public static Agent_Z getInstance(){
        System.out.println("单例模式，本地区只有我张三一个代理！");
        return agent;
    }

    private String name;
    private Integer fee;

    static {
        agent.setName("张三");
        agent.setFee(500);
    }
}
```
+ 李四的名片
```
public class Agent_L {
    //无参构造
    private Agent_L(){};
    //实例化
    private static Agent_L agent=new Agent_L();
    //提供已经实例化的对象方便调用（李四印制自己的名片，准备发放）
    public static Agent_L getInstance(){
        System.out.println("单例模式，本地区只有我李四一个代理！");
        return agent;
    }

    private String name;
    private Integer fee;

    static {
        agent.setName("李四");
        agent.setFee(500);
    }
}
```
+ JDK动态代理加强方法
```
public class JDKProxy {
    public static Object getJDKProxy(Object o){
        return Proxy.newProxyInstance(o.getClass().getClassLoader(), o.getClass().getInterfaces(), new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                Object result;
                System.out.println("先收取代理费用500元");
                result = method.invoke(o, args);
                System.out.println("最后卖出客户信息5元");
                return result;
            }
        });
    }
}
```
+ Tom分别找两个代理公司租房
```
public class Tenant_Tom {
    public static void main(String[] args) {
        System.out.println("Tom在南方地区想要租房...");
        Agent_Z agent_z = Agent_Z.getInstance();
        System.out.println("获取名片："+agent_z);
        IRentingFactory rentingFactory_Z=(IRentingFactory)JDKProxy.getJDKProxy(new RentingFactory_Z());
        rentingFactory_Z.rent();

        System.out.println("---------------------");
        System.out.println("Tom在北方地区想要租房...");
        Agent_L agent_l = Agent_L.getInstance();
        System.out.println("获取名片："+agent_l);
        IRentingFactory rentingFactory_L=(IRentingFactory)JDKProxy.getJDKProxy(new RentingFactory_L());
        rentingFactory_L.rent();
    }
}
```
### 4. 结果演示
+ ![enter description here](https://img-1256282866.cos.ap-beijing.myqcloud.com/1627867501321.png)