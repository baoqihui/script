## 范围运算符

```
class Example { 
   static void main(String[] args) { 
      def range = 5..10; 
      println(range); 
      println(range.get(2)); 
   } 
}
·····················
[5, 6, 7, 8, 9, 10] 
7
```

# Groovy 字符串

Groovy提供了多种表示String字面量的方法。 Groovy中的字符串可以用单引号（'），双引号（“）或三引号（”“”）括起来。此外，由三重引号括起来的Groovy字符串可以跨越多行。

## 字符串索引

```
class Example { 
   static void main(String[] args) { 
      String sample = "Hello world"; 
      println(sample[4]); // Print the 5 character in the string
		
      //Print the 1st character in the string starting from the back 
      println(sample[-1]); 
      println(sample[1..2]);//Prints a string starting from Index 1 to 2 
      println(sample[4..2]);//Prints a string starting from Index 4 back to 2 
      
   } 
}
·················
o 
d 
el 
oll 
```

# Groovy 范围

范围是指定值序列的速记。范围由序列中的第一个和最后一个值表示，Range可以是包含或排除。包含范围包括从第一个到最后一个的所有值，而独占范围包括除最后一个之外的所有值。这里有一些范例文字的例子 - 

-  1..10 - 包含范围的示例
-  1 .. <10 - 独占范围的示例
-  'a'..'x' - 范围也可以由字符组成
-  10..1 - 范围也可以按降序排列
-  'x'..'a' - 范围也可以由字符组成并按降序排列。

# Groovy 列表

列表是用于存储数据项集合的结构。在 Groovy 中，List 保存了一系列对象引用。

List 中的对象引用占据序列中的位置，并通过整数索引来区分。

列表文字表示为一系列用逗号分隔并用方括号括起来的对象。

groovy 列表使用索引操作符 [] 索引。列表索引从 0 开始，指第一个元素。

groovy 中的一个列表中的数据可以是任意类型。这 java 下集合列表有些不同，java 下的列表是同种类型的数据集合。

groovy 列表可以嵌套列表。如 [1,2,[3,4,5],“aaa”] groovy 列表内置有反转方法 reverse()。调用  List.reverse() 可以实现列表反转。groovy 列表内置有排序方法 sort()。调用 List.sort()  可以实现列表排序。空列表表示为 [] 声明一个空集合：

```
//each遍历
[1, 2, 3].each {
    println "Item: $it"//it是对应于当前元素的隐式参数
}
//collect遍历原元素
assert [1, 2, 3].collect { it * 2 } == [2, 4, 6]
//find找出一个符合条件的元素
assert [1, 2, 3].find {it > 1 } == 2           
//findAll找出所有符合条件的元素
assert [1, 2, 3].findAll { it > 1 } == [2, 3]
```



# Groovy 特征

```
trait Marks {
   void DisplayMarks() {
      println("Display Marks");
   } 
}
```

Traits 可以实现接口，在这种情况下，使用 interface 关键字声明接口。

下面给出了实现接口的特征的示例。在以下示例中，可以注意以下要点。

- 接口 Total 使用方法 DisplayTotal 定义。
- 特征 Marks 实现了 Total 接口，因此需要为 DisplayTotal 方法提供一个实现。

```
class Example {
   static void main(String[] args) {
      Student st = new Student();
      st.StudentID = 1;
      st.Marks1 = 10;
		
      println(st.DisplayMarks());
      println(st.DisplayTotal());
   } 
} 

interface Total {
   void DisplayTotal() 
} 

trait Marks implements Total {
   void DisplayMarks() {
      println("Display Marks");
   }
	
   void DisplayTotal() {
      println("Display Total"); 
   } 
} 

class Student implements Marks { 
   int StudentID
   int Marks1;  
} 
·····················
Display Marks 
Display Total
```

## 属性

特征可以定义属性。下面给出了具有属性的trait的示例。

```
class Example {
   static void main(String[] args) {
      Student st = new Student();
      st.StudentID = 1;
		
      println(st.DisplayMarks());
      println(st.DisplayTotal());
   } 
	
   interface Total {
      void DisplayTotal() 
   } 
	
   trait Marks implements Total {
      int Marks1;
		
      void DisplayMarks() {
         this.Marks1 = 10;
         println(this.Marks1);
      }
		
      void DisplayTotal() {
         println("Display Total");
      } 
   } 
	
   class Student implements Marks {
      int StudentID 
   }
} 
·············
10 
Display Total
```

## 行为的构成

特征可以用于以受控的方式实现多重继承，避免钻石问题。在下面的代码示例中，我们定义了两个特征 - Marks 和 Total。我们的 Student 类实现了两个特征。由于学生类扩展了这两个特征，它能够访问这两种方法 - DisplayMarks 和 DisplayTotal。

```
class Example {
   static void main(String[] args) {
      Student st = new Student();
      st.StudentID = 1;
		
      println(st.DisplayMarks());
      println(st.DisplayTotal()); 
   } 
} 

trait Marks {
   void DisplayMarks() {
      println("Marks1");
   } 
} 

trait Total {
   void DisplayTotal() { 
      println("Total");
   } 
}  

class Student implements Marks,Total {
   int StudentID 
}   
················
Marks1
Total 
```

# Groovy 闭包

闭包是一个短的匿名代码块。它通常跨越几行代码。一个方法甚至可以将代码块作为参数。它们是匿名的。

```
class Example {
   static void main(String[] args) {
      def clos = {println "Hello World"};
      clos.call();
   } 
}
···················
Hello World
```

## 闭包中的形式参数

闭包也可以包含形式参数，以使它们更有用，就像Groovy中的方法一样。

```
class Example {
   static void main(String[] args) {
      def clos = {param->println "Hello ${param}"};
      clos.call("World");
   } 
}
```

## 闭包和变量

更正式地，闭包可以在定义闭包时引用变量。以下是如何实现这一点的示例。

```
class Example {     
   static void main(String[] args) {
      def str1 = "Hello";
      def clos = {param -> println "${str1} ${param}"}
      clos.call("World");
		
      // We are now changing the value of the String str1 which is referenced in the closure
      str1 = "Welcome";
      clos.call("World");
   } 
}
```

然后我们在我们的main方法中定义一个闭包，并将它作为一个参数传递给我们的Display方法。

### 使用闭包和列表

以下示例显示如何使用闭包与列表。在下面的例子中，我们首先定义一个简单的值列表。列表集合类型然后定义一个名为.each的函数。此函数将闭包作为参数，并将闭包应用于列表的每个元素

```
class Example {
   static void main(String[] args) {
      def lst = [1,2,3,4];
      lst.each {println it}
      println("The list will only display those numbers which are divisible by 2")
      lst.each{num -> if(num % 2 == 0) println num}
   } 
}
····················
1 
2 
3 
4 
The list will only display those numbers which are divisible by 2.
2 
4 
```

### 使用映射闭包

以下示例显示了如何使用闭包。在下面的例子中，我们首先定义一个简单的关键值项Map。然后，映射集合类型定义一个名为.each的函数。此函数将闭包作为参数，并将闭包应用于映射的每个键值对。

```
class Example {
   static void main(String[] args) {
      def mp = ["TopicName" : "Maps", "TopicDescription" : "Methods in Maps"]             
      mp.each {println it}
      mp.each {println "${it.key} maps to: ${it.value}"}
   } 
}
···············
TopicName = Maps 
TopicDescription = Methods in Maps 
TopicName maps to: Maps 
TopicDescription maps to: Methods in Maps
```

# Groovy DSLS

```
class EmailDsl {  
   String toText 
   String fromText 
   String body 
	
   /** 
   * This method accepts a closure which is essentially the DSL. Delegate the 
   * closure methods to 
   * the DSL class so the calls can be processed 
   */ 
   
   def static make(closure) { 
      EmailDsl emailDsl = new EmailDsl() 
      // any method called in closure will be delegated to the EmailDsl class 
      closure.delegate = emailDsl
      closure() 
   }
   
   /** 
   * Store the parameter as a variable and use it later to output a memo 
   */ 
	
   def to(String toText) { 
      this.toText = toText 
   }
   
   def from(String fromText) { 
      this.fromText = fromText 
   }
   
   def body(String bodyText) { 
      this.body = bodyText 
   } 
}

EmailDsl.make { 
   to "Nirav Assar" 
   from "Barack Obama" 
   body "How are things? We are doing well. Take care" 
}
··············
How are things? We are doing well. Take care
```

# 注解

|       注解        |                             含义                             | 示例                                                  |
| :---------------: | :----------------------------------------------------------: | ----------------------------------------------------- |
| @TupleConstructor | 编译时自动创建一个元组构造函数。 因此构造函数可以在编译的类中找到。 对于类中的每个属性，将使用默认值创建构造函数中的参数。  类中定义的属性的顺序还定义了构造函数中参数的顺序。  因为参数具有默认值，所以我们可以使用Groovy语法，并在使用构造函数时将参数留在参数列表的末尾。 | def person = new Person('mrhaki', ['Groovy', 'Java']) |
|    @Immutable     |                                                              |                                                       |
|                   |                                                              |                                                       |

